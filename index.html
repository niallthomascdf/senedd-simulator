None selected

Skip to content
Using Gmail with screen readers
4 of 6
final wales sim
Inbox

Niall Thomas
Attachments
3:44 PM (2 hours ago)
to me


 One attachment
  •  Scanned by Gmail
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welsh Senedd Election Simulator</title>
    <!-- Use Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use the Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base font-family and styling */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Hide number input spin buttons for a cleaner look */
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }

        /* Styling for the coalition filter buttons */
        .filter-button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .filter-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px -1-px rgba(0, 0, 0, 0.1), 0 4px 6px -1px rgba(0, 0, 0, 0.06);
        }
        .filter-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
        }

        /* Styling for the loading spinner animation */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #ffffff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Class to hide table rows for filtering coalitions */
        .hidden-row {
            display: none;
        }

        /* Ensure <b> tags are always bold */
        b {
            font-weight: bold;
        }

        /* Styles for RAG dots */
        .rag-dot {
            height: 12px;
            width: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .rag-red { background-color: #ef4444; }
        .rag-amber { background-color: #f97316; }
        .rag-green { background-color: #22c55e; }
    </style>
</head>
<body class="bg-gray-100 p-4 min-h-screen">
    <div class="max-w-4xl mx-auto w-full bg-white rounded-2xl shadow-xl overflow-hidden p-8 space-y-8">

        <!-- Header Section -->
        <header class="text-center space-y-2">
            <h1 class="text-4xl font-bold text-gray-800 tracking-tight">
                Welsh Senedd Election Simulator
            </h1>
            <p class="text-gray-500">
                Predicting outcomes for the Welsh Senedd elections using latest and historical polling data
            </p>
        </header>

        <!-- Methodology Section (Collapsible) -->
        <details class="bg-gray-50 p-6 rounded-xl border border-gray-200 group">
            <summary class="text-xl font-semibold flex items-center gap-2 text-gray-700 cursor-pointer">
                <!-- Lucide icon for Methodology -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-blue-500 group-open:rotate-90 transition-transform"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
                Methodology
            </summary>
            <div class="mt-3 text-sm text-gray-600 methodology-content">
                <p>This simulator uses a <b>Monte Carlo simulation</b> to predict election outcomes. It runs <b>20,000 individual simulations</b>, each representing a possible election day scenario. For each simulation, poll numbers are adjusted based on historical "polling trend" data and a random "jitter" to account for natural polling variability.</p>
                
                <h3 class="font-semibold mt-4 text-gray-700">How Votes are Converted to Seats:</h3>
                <ul class="list-disc list-inside ml-4 text-xs space-y-1">
                    <li><b>For Elections from 2026 Onwards (96 Seats):</b> The Senedd will move to a new system with 16 multi-member constituencies, each electing six Members (96 total). This simulator applies the <b>D'Hondt method</b> directly to the overall (national) party vote percentages to allocate all 96 seats proportionally. This is a simplification, as the actual system allocates seats on a constituency-by-constituency basis.</li>
                    <li><b>Historical Elections (Prior to 2026, 60 Seats):</b> These elections used an Additional Member System:
                        <ul class="list-disc list-inside ml-4">
                            <li><b>Constituency Seats (40 seats):</b> Allocated using a simplified <b>First-Past-the-Post (FPTP) proxy</b>.</li>
                            <li><b>Regional List Seats (20 seats):</b> Allocated using the <b>D'Hondt method</b> to balance overall proportionality.</li>
                        </ul>
                    </li>
                </ul>

                <h3 class="font-semibold mt-4 text-gray-700">Polling Trends & Jitter:</h3>
                <ul class="list-disc list-inside ml-4 text-xs space-y-1">
                    <li><b>Rolling Average:</b> The simulation starts with a rolling average of the <b>last 5 polls</b> to establish a baseline for party support.</li>
                    <li><b>Jitter:</b> A random "jitter" is added to each party's poll number in every simulation. This jitter is a measure of the party's historical polling volatility, calculated as the standard deviation of the difference between a party's final pre-election polling average and its actual election result from past Senedd elections (2011, 2016, and 2021). This gives a more accurate representation of each party's historical predictability.</li>
                    <li><b>Historical Trends:</b> The simulation incorporates an <b>averaged historical trend</b> derived from past Welsh Assembly/Senedd elections. For each historical election, a <b>weighted average of all pre-election polls</b> is calculated (giving more weight to polls closer to the election date). The trend for that election is then the difference between the actual election result and this weighted average of pre-election polls. These individual election trends are then averaged, with <b>more recent election years receiving a higher weight</b>, to create the overall historical trend applied to current polling.</li>
                </ul>
                
                <h3 class="font-semibold mt-4 text-gray-700">Important Notes:</h3>
                <ul class="list-disc list-inside ml-4 text-xs space-y-1">
                    <li>The "Others" party acts as a general category for smaller parties and independents. Its votes contribute to seat allocation but it is not considered for explicit coalition formation.</li>
                    <li>For simplicity, the model applies national polling trends and does not account for specific regional variations in voter swings or local constituency dynamics, especially under the new multi-member constituency system.</li>
                </ul>
            </div>
        </details>

        <!-- Warning about electoral system change -->
        <p class="text-center text-red-600 font-semibold text-sm mt-4">
            N.B. The electoral system used to elect the Senedd will change at the next election. As a result, historical polls give a less accurate picture than they may normally would.
        </p>

        <!-- Latest Polls Section (Collapsible) -->
        <details class="space-y-4 bg-gray-50 p-6 rounded-xl border border-gray-200 group">
            <summary class="text-xl font-semibold flex items-center gap-2 text-gray-700 cursor-pointer">
                <!-- Lucide icon for Polls -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-indigo-500 group-open:rotate-90 transition-transform"><path d="M3 3v18h18"/><path d="M18 17V9"/><path d="M13 17V5"/><path d="M8 17v-3"/></svg>
                Latest Polls
            </summary>
            <div class="mt-3 text-sm text-gray-600 space-y-4">
                <div id="current-polls-table-container" class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th rowspan="2" scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Poll Date
                                </th>
                                <th rowspan="2" scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Pollster
                                </th>
                                <th colspan="7" scope="colgroup" class="px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-gray-200">
                                    Overall Vote (%)
                                </th>
                            </tr>
                            <tr id="party-headers-row">
                                <!-- Party headers will be generated by JavaScript -->
                            </tr>
                        </thead>
                        <tbody id="current-polls-table-body" class="bg-white divide-y divide-gray-200">
                            <!-- Poll data rows will be rendered here by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div id="current-polls-message" class="text-center text-sm font-semibold h-5 mt-4"></div>
            </div>
        </details>

        <!-- Data Input Section (Collapsible) -->
        <details class="space-y-4 bg-white p-6 rounded-xl border border-gray-200 group">
            <summary class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center cursor-pointer">
                <!-- Lucide icon for new poll -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-emerald-500 group-open:rotate-90 transition-transform"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
                Add a New Poll (Optional)
            </summary>
            <p class="text-center text-gray-500 text-sm">
                Enter the overall vote percentages for a new poll (for the 2026 election system). If left blank, the simulator will use the last 5 polls in its database.
            </p>
            <div id="poll-message-container" class="text-center text-sm font-semibold h-5 mb-2"></div>
            <div class="grid md:grid-cols-1 gap-8">
                <div class="space-y-4">
                    <h3 class="text-xl font-semibold flex items-center gap-2 text-gray-700">
                        <!-- Lucide icon for vote percentages -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-green-500"><path d="M3 3v18h18"/><path d="M7 16l4-7 4 7 5-7"/></svg>
                        Overall Vote %
                    </h3>
                    <div id="new-overall-inputs" class="space-y-4">
                        <!-- Inputs will be generated here by JavaScript -->
                    </div>
                    <div id="overall-sum" class="text-right text-sm font-semibold">Total: <span class="overall-total-value">0.0</span>%</div>
                </div>
            </div>
        </details>

        <!-- Discounting Checkboxes -->
        <div class="flex flex-col md:flex-row justify-center gap-4 mt-4">
            <div class="flex items-center space-x-2 bg-gray-50 p-3 rounded-xl border border-gray-200">
                <input type="checkbox" id="enable-trend-application" class="form-checkbox h-5 w-5 text-indigo-600 rounded-md border-gray-300" checked>
                <label for="enable-trend-application" class="text-gray-700 text-sm">Enable historical trend application</label>
            </div>
        </div>
        
        <!-- Run Simulation Button -->
        <div class="flex justify-center mt-4">
            <button id="run-simulation-button" class="bg-gray-900 text-white font-bold py-3 px-6 rounded-full text-lg hover:bg-gray-800 transition-colors filter-button flex items-center justify-center gap-2">
                <span id="button-text">Run Simulation</span>
                <div id="loading-spinner" class="loading-spinner hidden"></div>
            </button>
        </div>

        <!-- Seats Required for a Majority -->
        <div class="mt-8 text-center bg-blue-50 p-6 rounded-xl border border-blue-200 shadow-sm">
            <h3 class="text-lg font-semibold text-blue-700 flex items-center justify-center gap-2">
                <!-- Lucide icon for seats -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-blue-500"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                Seats Required for a Majority
            </h3>
            <p class="mt-2 text-xl font-bold text-blue-900">
                49
            </p>
        </div>

        <!-- Simulation Results Section -->
        <div class="space-y-4">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center">
                <!-- Lucide icon for results -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-red-500"><line x1="4" x2="20" y1="9" y2="9"/><path d="M21 15V9a2 2 0 0 0-2-2H5a2 2 0 0 0 2 2v6a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2z"/></svg>
                Simulation Results (20,000 Runs)
            </h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Party
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Majority
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Plurality
                            </th>
                        </tr>
                    </thead>
                    <tbody id="probability-table" class="bg-white divide-y divide-gray-200">
                        <!-- Probabilities will be rendered here by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Predicted Seat Distribution Section -->
        <div class="space-y-4">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center">
                <!-- Lucide icon for seat distribution -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-blue-500"><path d="M3 15v4a2 2 0 0 0-2 2h14a2 2 0 0 0 2-2v-4M12 12V2M15 5l-3-3-3 3"/></svg>
                Predicted Seat Distribution (Average of 20,000 Simulations)
            </h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Party
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Average Seats
                            </th>
                        </tr>
                    </thead>
                    <tbody id="forecasted-seats-table" class="bg-white divide-y divide-gray-200">
                        <!-- Forecasted seats will be generated here by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Coalition Analysis Section -->
        <div class="space-y-4">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center">
                <!-- Lucide icon for coalition -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-purple-500"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                Coalition Analysis (Based on Simulations)
            </h2>
            <div class="flex justify-center space-x-4 mb-4">
                <button id="toggle-red-button" class="filter-button bg-gray-500 text-white font-bold py-2 px-4 rounded-full">
                    Show Red rated coalitions
                </button>
                <button id="toggle-amber-button" class="filter-button bg-amber-500 text-white font-bold py-2 px-4 rounded-full">
                    Hide Amber rated coalitions
                </button>
            </div>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Coalition <span class="block text-gray-400 text-xs">(Av. Seats/Highest Seats)</span>
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Political Viability
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Majority
                                <span class="block text-gray-400 text-xs">(&ge; 49 Seats)</span>
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Near-Majority
                                <span class="block text-gray-400 text-xs">(46-48 Seats)</span>
                            </th>
                            <th scope="col" class="px-6 py-3 text-left text-sm font-medium text-gray-500 uppercase tracking-wider">
                                Likely Lead Party
                            </th>
                        </tr>
                    </thead>
                    <tbody id="coalition-table" class="bg-white divide-y divide-gray-200">
                        <!-- Coalition probabilities will be rendered here by JavaScript -->
                    </tbody>
                </table>
            </div>
            <div id="coalition-message" class="text-center text-sm font-semibold h-5 mt-4"></div>
        </div>
        
        <!-- Key Takeaways Section -->
        <div class="space-y-4 bg-purple-50 p-6 rounded-xl border border-purple-200 shadow-sm">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center text-purple-700">
                <!-- Lucide icon for takeaways -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-purple-500"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path d="M14 2v6h6"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>
                Key Takeaways from Simulation
            </h2>
            <ul id="key-takeaways-list" class="list-disc list-inside ml-4 text-gray-800 space-y-2">
                <!-- Key takeaways will be rendered here by JavaScript -->
            </ul>
        </div>
    </div>

    <script>
        // Wrap the entire script in an IIFE to encapsulate variables and avoid global scope issues
        (function() {
            const millisecondsPerDay = 1000 * 60 * 60 * 24;

            // Global variable to store the averaged historical trend
            let averagedHistoricalTrend = { old_constituency: {}, old_regional: {} };
            // Global variable to store the actual current polls being used (full objects with dates)
            let currentPollsInUse = [];

            document.addEventListener('DOMContentLoaded', async () => {
                // Updated party names and colors/jitter factors for Welsh Senedd
                const parties = [
                    { name: 'Labour', color: '#E4003B', jitterFactor: 0.03 }, // Welsh Labour
                    { name: 'Plaid Cymru', color: '#008142', jitterFactor: 0.02 }, // Plaid Cymru (dark green)
                    { name: 'Conservative', color: '#0187DC', jitterFactor: 0.035 }, // Welsh Conservatives
                    { name: 'Liberal Democrats', color: '#FAA61A', jitterFactor: 0.06 }, // Welsh Liberal Democrats
                    { name: 'Green', color: '#78B159', jitterFactor: 0.06 }, // Wales Green Party
                    { name: 'Reform', color: '#12B2E6', jitterFactor: 0.05 }, // Reform UK Wales
                    { name: 'Others', color: '#CCCCCC', jitterFactor: 0.07 }
                ];

                // Define aliases for party names to handle variations in sheet headers
                const partyHeaderAliases = {
                    'Labour': 'Labour',
                    'Lab': 'Labour',
                    'Plaid Cymru': 'Plaid Cymru',
                    'Plaid': 'Plaid Cymru',
                    'PC': 'Plaid Cymru',
                    'Conservative': 'Conservative',
                    'Conservatives': 'Conservative',
                    'Con': 'Conservative',
                    'Liberal Democrat': 'Liberal Democrats',
                    'Liberal Democrats': 'Liberal Democrats',
                    'Lib Dem': 'Liberal Democrats',
                    'LD': 'Liberal Democrats',
                    'Green': 'Green',
                    'Greens': 'Green',
                    'Reform UK': 'Reform',
                    'Reform': 'Reform',
                    'Others': 'Others',
                    'Other': 'Others',
                    'UKIP': 'Others', // UKIP used to be a factor in Wales, now generally Others
                    'Abolish': 'Others' // Abolish the Welsh Assembly Party
                };

                // --- Constants and DOM Elements ---
                // The URL of your deployed Google Apps Script Web App acting as a CORS proxy.
                const appsScriptProxyUrl = "https://script.google.com/macros/s/AKfycbwjvqSRSfYnDLpdbQF2APw1-EGPPv3REZiX8POP4SNZTP0iE9ylvsJi7KPg22Q1SPwHuw/exec";
                
                // Current Polls GID
                const currentPollsGid = '1550759519'; 

                // Historical Election GIDs
                // The data sheets contain actual results in row 2 and polls from row 3 onwards.
                const historicalElectionData = [
                    { year: 2021, constituencyGid: '819802892', regionalGid: '1188969757', electionDate: new Date('2021-05-06T00:00:00Z'), yearWeight: 1.0 },
                    { year: 2016, constituencyGid: '718925928', regionalGid: '89652159', electionDate: new Date('2016-05-05T00:00:00Z'), yearWeight: 0.8 },
                    { year: 2011, constituencyGid: '1485069294', regionalGid: '274836084', electionDate: new Date('2011-05-05T00:00:00Z'), yearWeight: 0.6 }
                ];

                const totalNewSeneddSeats = 96;
                const totalOldSeneddSeats = 60;
                const totalOldConstituencySeats = 40;
                const totalOldRegionalSeats = 20;

                const majoritySeats = Math.floor(totalNewSeneddSeats / 2) + 1;
                const nearMajoritySeats = 46;
                const numSimulations = 20000;
                const mainParties = parties.filter(p => p.name !== 'Others').map(p => p.name);
                const nextSeneddElectionDate = new Date('2026-05-07T00:00:00Z');

                const newOverallInputsDiv = document.getElementById('new-overall-inputs');
                const runSimulationButton = document.getElementById('run-simulation-button');
                const probabilityTableBody = document.getElementById('probability-table');
                const coalitionTableBody = document.getElementById('coalition-table');
                const forecastedSeatsTableBody = document.getElementById('forecasted-seats-table');
                const toggleRedButton = document.getElementById('toggle-red-button');
                const toggleAmberButton = document.getElementById('toggle-amber-button');
                const buttonTextSpan = document.getElementById('button-text');
                const loadingSpinner = document.getElementById('loading-spinner');
                const pollMessageContainer = document.getElementById('poll-message-container');
                const overallSumSpan = document.querySelector('.overall-total-value');
                const keyTakeawaysList = document.getElementById('key-takeaways-list');
                const enableTrendApplicationCheckbox = document.getElementById('enable-trend-application');
                const currentPollsTableBody = document.getElementById('current-polls-table-body');
                const partyHeadersRow = document.getElementById('party-headers-row');
                const currentPollsMessageDiv = document.getElementById('current-polls-message');
                const coalitionMessageDiv = document.getElementById('coalition-message');

                let hiddenRed = true;
                let hiddenAmber = false;

                // Global storage for last simulation results to be used by takeaways
                let lastSimResults = {
                    majorityProbabilities: {},
                    pluralityProbabilities: {},
                    averageSeats: {},
                    coalitionsToRender: []
                };

                // --- Data Fetching and Parsing Functions ---
                
                /**
                 * Fetches and parses a Google Sheet CSV from a given URL.
                 * This function has been refactored to be more robust. It can parse polls from a CSV string
                 * and optionally handle a specific starting row for the data.
                 * @param {string} csvText The raw CSV text.
                 * @param {string} sheetName A friendly name for logging purposes.
                 * @param {number} dataStartRow The 0-indexed row number where the actual data begins.
                 * @returns {Array<Object>} An array of poll objects.
                 */
                const parseGoogleSheetData = (csvText, sheetName = "Unknown Sheet", dataStartRow = 1) => {
                    console.log(`--- Parsing CSV for ${sheetName} ---`);
                    const polls = [];
                    const lines = csvText.split('\n');
                    if (lines.length <= dataStartRow) {
                        console.warn(`[${sheetName}] CSV has too few lines (<= ${dataStartRow}). Returning empty array.`);
                        return [];
                    }

                    const rawHeaders = lines[0].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(h => h.trim().replace(/^"|"$/g, ''));
                    const headerMap = {};
                    rawHeaders.forEach((h, i) => {
                        const canonicalName = partyHeaderAliases[h];
                        if (canonicalName) {
                            headerMap[canonicalName] = i;
                        }
                    });

                    for (let i = dataStartRow; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;

                        const rawValues = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => v.trim().replace(/^"|"$/g, ''));
                        
                        const poll = { parties: {} };
                        let pollDate = null;
                        let pollsterName = '';
                        const dateColumnIndex = rawHeaders.findIndex(h => h.toLowerCase() === 'dates conducted');
                        const pollsterColumnIndex = rawHeaders.findIndex(h => h.toLowerCase() === 'pollster');


                        if (dateColumnIndex !== -1 && rawValues[dateColumnIndex] !== undefined) {
                            let rawDateString = rawValues[dateColumnIndex].trim();
                            let dateToParse = rawDateString;
                            const dateRangeRegex = /^(\d{1,2}\s[A-Za-z]+).*?(\d{4})$/;
                            const singleDateRegex = /^(\d{1,2}\s[A-Za-z]+\s\d{4})$/;
                            const matchRange = rawDateString.match(dateRangeRegex);
                            const matchSingle = rawDateString.match(singleDateRegex);

                            if (matchRange && matchRange[1] && matchRange[2]) {
                                dateToParse = `${matchRange[1]} ${matchRange[2]}`;
                            } else if (matchSingle && matchSingle[1]) {
                                dateToParse = matchSingle[1];
                            } else {
                                console.warn(`[${sheetName}] Date format not fully recognized for '${rawDateString}'. Attempting direct parse.`);
                            }
                            const parsedDate = new Date(dateToParse);
                            if (!isNaN(parsedDate.getTime())) {
                                pollDate = parsedDate;
                            } else {
                                console.warn(`[${sheetName}] Failed to parse date '${rawDateString}'. Date object will be null.`);
                            }
                        }
                        poll.date = pollDate;
                        poll.rawDateString = rawValues[dateColumnIndex] || '';

                        if (pollsterColumnIndex !== -1 && rawValues[pollsterColumnIndex] !== undefined) {
                            pollsterName = rawValues[pollsterColumnIndex].trim();
                        }
                        poll.pollster = pollsterName;

                        let hasAnyValidPartyDataInRow = false;
                        parties.forEach(p => {
                            const colIndex = headerMap[p.name];
                            let value = 0;
                            if (colIndex !== undefined && rawValues[colIndex] !== undefined && rawValues[colIndex] !== '') {
                                const match = rawValues[colIndex].match(/\d+(\.\d+)?/);
                                if (match) {
                                    const parsedValue = parseFloat(match[0]);
                                    if (!isNaN(parsedValue)) {
                                        value = parsedValue;
                                        if (value !== 0) {
                                            hasAnyValidPartyDataInRow = true;
                                        }
                                    } else {
                                        console.warn(`[${sheetName}] Party '${p.name}' data in row ${i} ('${rawValues[colIndex]}') matched a number but it's NaN after parsing. Setting to 0.`);
                                    }
                                } else {
                                    if (rawValues[colIndex].trim() !== '') {
                                        console.warn(`[${sheetName}] Party '${p.name}' data in row ${i} ('${rawValues[colIndex]}') contains no valid number. Setting to 0.`);
                                    }
                                }
                            }
                            poll.parties[p.name] = value;
                        });

                        if (hasAnyValidPartyDataInRow) {
                            polls.push(poll);
                        } else {
                            console.log(`[${sheetName}] Skipping row ${i}: No valid, non-zero party data found.`);
                        }
                    }
                    
                    // We only sort if there's a valid date to sort by
                    if (polls.some(p => p.date !== null)) {
                        polls.sort((a, b) => (a.date ? a.date.getTime() : Infinity) - (b.date ? b.date.getTime() : Infinity));
                    }
                    
                    console.log(`--- Finished parsing CSV for ${sheetName} ---`);
                    return polls;
                };


                /**
                 * Normalizes vote percentages to ensure they sum to 100.
                 * @param {Object} votes An object with party names as keys and vote percentages as values.
                 * @returns {Object} A new object with normalized vote percentages.
                 */
                const normalizeVotes = (votes) => {
                    let total = 0;
                    for (const party in votes) {
                        if (votes[party] > 0) {
                            total += votes[party];
                        }
                    }
                    
                    if (total === 0) return votes;
                    const factor = 100 / total;
                    const normalizedVotes = {};
                    for (const party in votes) {
                        const normalizedValue = votes[party] * factor;
                        normalizedVotes[party] = normalizedValue < 0 ? 0 : normalizedValue;
                    }
                    return normalizedVotes;
                };

                /**
                 * Fetches current polls from the Google Sheet and prepares them for the simulation.
                 * It takes the latest 5 polls and normalizes their vote percentages.
                 * @returns {Promise<Array<Object>|null>} A promise that resolves to an array of poll objects, or null if fetching fails.
                 */
                const fetchPollsFromGoogleSheet = async () => {
                    try {
                        console.log("Attempting to fetch current polls for new Senedd system...");
                        const overallUrl = `${appsScriptProxyUrl}?gid=${currentPollsGid}`;
                        const overallResponse = await fetch(overallUrl);
                        if (!overallResponse.ok) {
                            console.error(`HTTP error fetching overall poll data! status: ${overallResponse.status}`);
                            throw new Error(`HTTP error! status: ${overallResponse.status}`);
                        }
                        const overallCsvText = await overallResponse.text();
                        // Current polls start at row 2 (after header row 1)
                        const overallPollsFull = parseGoogleSheetData(overallCsvText, "Current Overall Polls", 1);
                        console.log(`Current Polls: Overall polls (full objects) length: ${overallPollsFull.length}`);
                        
                        const combinedPollsFull = [];
                        overallPollsFull.sort((a, b) => (b.date ? b.date.getTime() : 0) - (a.date ? a.date.getTime() : 0));

                        const numPollsToConsider = Math.min(overallPollsFull.length, 5);
                        for (let i = 0; i < numPollsToConsider; i++) {
                            combinedPollsFull.push({
                                date: overallPollsFull[i].date,
                                rawDateString: overallPollsFull[i].rawDateString,
                                pollster: overallPollsFull[i].pollster || '',
                                constituency: normalizeVotes(overallPollsFull[i].parties),
                                regional: {}
                            });
                        }
                        
                        return combinedPollsFull;
                    } catch (error) {
                        console.error("Could not fetch current poll data. Check console for details.", error);
                        return null;
                    }
                };

                /**
                 * Calculates a weighted average for a set of polls.
                 * @param {Array<Object>} polls An array of poll objects.
                 * @param {Date} electionDate The date of the election.
                 * @returns {Object} An object with party names as keys and weighted average percentages as values.
                 */
                const calculateWeightedAverageForPolls = (polls, electionDate) => {
                    const weightedSums = {};
                    let totalOverallWeight = 0;
                    const partiesForTrend = parties.map(p => p.name);
                    partiesForTrend.forEach(p => weightedSums[p] = 0);
                    
                    for (const poll of polls) {
                        if (!poll.date) continue;
                        const daysBeforeElection = Math.max(0, Math.floor((electionDate.getTime() - poll.date.getTime()) / millisecondsPerDay));
                        const weight = 1 / (daysBeforeElection + 1);

                        for (const partyName in poll.parties) {
                            if (partiesForTrend.some(p => p === partyName)) {
                                weightedSums[partyName] += (poll.parties[partyName] || 0) * weight;
                            }
                        }
                        totalOverallWeight += weight;
                    }

                    const weightedAverages = {};
                    if (totalOverallWeight === 0) {
                        partiesForTrend.forEach(p => weightedAverages[p] = 0);
                        return weightedAverages;
                    }

                    partiesForTrend.forEach(p => {
                        weightedAverages[p] = weightedSums[p] / totalOverallWeight;
                    });
                    return weightedAverages;
                };

                /**
                 * Fetches and calculates historical polling trends based on past elections.
                 * This function is updated to apply the Conservative trend to Reform.
                 * @returns {Promise<Object>} A promise that resolves to an object containing the averaged historical trends.
                 */
                const fetchHistoricalTrends = async () => {
                    console.log("Attempting to fetch historical trends...");
                    const isTrendApplicationEnabled = enableTrendApplicationCheckbox.checked;
                    let allConstituencyTrendsSum = {};
                    let allRegionalTrendsSum = {};
                    let totalYearWeightForConst = 0;
                    let totalYearWeightForReg = 0;
                    parties.forEach(p => {
                        allConstituencyTrendsSum[p.name] = 0;
                        allRegionalTrendsSum[p.name] = 0;
                    });

                    for (const election of historicalElectionData) {
                        try {
                            const constPollsResponse = await fetch(`${appsScriptProxyUrl}?gid=${election.constituencyGid}`);
                            const regPollsResponse = await fetch(`${appsScriptProxyUrl}?gid=${election.regionalGid}`);
                            
                            if (!constPollsResponse.ok || !regPollsResponse.ok) {
                                console.error(`HTTP error fetching historical data for ${election.year}! Skipping trends for this year.`);
                                continue;
                            }

                            const constPollsCsvText = await constPollsResponse.text();
                            const regPollsCsvText = await regPollsResponse.text();
                            
                            // Data sheet has results in row 2 (index 1) and polls start in row 3 (index 2)
                            const actualConstResult = normalizeVotes(parseGoogleSheetData(constPollsCsvText, `Historical ${election.year} Actual Constituency Results`, 1)[0].parties);
                            const actualRegResult = normalizeVotes(parseGoogleSheetData(regPollsCsvText, `Historical ${election.year} Actual Regional Results`, 1)[0].parties);

                            const allConstPollsForElection = parseGoogleSheetData(constPollsCsvText, `Historical ${election.year} Constituency Polls`, 2);
                            const allRegPollsForElection = parseGoogleSheetData(regPollsCsvText, `Historical ${election.year} Regional Polls`, 2);


                            if (!actualConstResult || !actualRegResult) {
                                console.warn(`Actual election results missing or invalid for ${election.year}. Cannot calculate trend. Skipping.`);
                                continue;
                            }

                            const weightedAvgConstPoll = calculateWeightedAverageForPolls(allConstPollsForElection, election.electionDate);
                            const weightedAvgRegPoll = calculateWeightedAverageForPolls(allRegPollsForElection, election.electionDate);

                            parties.forEach(p => {
                                // Only calculate trend for parties with historical data
                                const constTrend = (actualConstResult[p.name] || 0) - (weightedAvgConstPoll[p.name] || 0);
                                const regTrend = (actualRegResult[p.name] || 0) - (weightedAvgRegPoll[p.name] || 0);
                                
                                allConstituencyTrendsSum[p.name] += constTrend * election.yearWeight;
                                allRegionalTrendsSum[p.name] += regTrend * election.yearWeight;
                            });

                            totalYearWeightForConst += election.yearWeight;
                            totalYearWeightForReg += election.yearWeight;

                        } catch (error) {
                            console.error(`Error processing historical data for ${election.year}:`, error);
                        }
                    }

                    const finalAveragedTrend = { old_constituency: {}, old_regional: {} };
                    if (isTrendApplicationEnabled && (totalYearWeightForConst > 0 || totalYearWeightForReg > 0)) {
                        parties.forEach(p => {
                            finalAveragedTrend.old_constituency[p.name] = totalYearWeightForConst > 0 ? (allConstituencyTrendsSum[p.name] / totalYearWeightForConst) : 0;
                            finalAveragedTrend.old_regional[p.name] = totalYearWeightForReg > 0 ? (allRegionalTrendsSum[p.name] / totalYearWeightForReg) : 0;
                        });

                        // Apply the Conservative trend to Reform
                        const consTrendConst = finalAveragedTrend.old_constituency['Conservative'];
                        const consTrendReg = finalAveragedTrend.old_regional['Conservative'];
                        finalAveragedTrend.old_constituency['Reform'] = consTrendConst;
                        finalAveragedTrend.old_regional['Reform'] = consTrendReg;

                        console.log("Averaged Historical Trends (Weighted by Year):", finalAveragedTrend);

                    } else {
                        parties.forEach(p => {
                            finalAveragedTrend.old_constituency[p.name] = 0;
                            finalAveragedTrend.old_regional[p.name] = 0;
                        });
                        console.warn("Historical trend application is disabled or no meaningful historical trends could be loaded. Simulation will run without historical swings (trends set to 0).");
                    }
                    return finalAveragedTrend;
                };

                /**
                 * Main function to update data and run the simulation.
                 */
                const updateAndRunSimulation = async () => {
                    console.log("updateAndRunSimulation started.");
                    // Show immediate loading state feedback
                    buttonTextSpan.textContent = "Simulating...";
                    loadingSpinner.classList.remove('hidden');
                    runSimulationButton.disabled = true;
                    pollMessageContainer.textContent = "Fetching data from Google Sheet...";
                    pollMessageContainer.className = "text-center text-sm font-semibold h-5 mb-2 text-gray-600";

                    window.requestAnimationFrame(async () => {
                        try {
                            averagedHistoricalTrend = await fetchHistoricalTrends();
                            currentPollsInUse = (await fetchPollsFromGoogleSheet()) || [];
                            
                            setTimeout(() => {
                                try {
                                    runMonteCarloSimulation();
                                    renderCurrentPollsTable(currentPollsInUse);
                                    console.log("Simulation run completed successfully.");
                                } catch (simError) {
                                    console.error("Error during Monte Carlo simulation run:", simError);
                                    showTempMessage("An error occurred during simulation. Check console for details.", "text-red-500");
                                } finally {
                                    buttonTextSpan.textContent = "Run Simulation";
                                    loadingSpinner.classList.add('hidden');
                                    runSimulationButton.disabled = false;
                                }
                            }, 50);
                        } catch (fetchError) {
                            console.error("Error during data fetching in updateAndRunSimulation:", fetchError);
                            showTempMessage("An error occurred during data loading. Check console for details.", "text-red-500");
                            buttonTextSpan.textContent = "Run Simulation";
                            loadingSpinner.classList.add('hidden');
                            runSimulationButton.disabled = false;
                            probabilityTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="3" class="px-6 py-4">Error loading data.</td></tr>`;
                            coalitionTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="5" class="px-6 py-4">Error loading data.</td></tr>`;
                            forecastedSeatsTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="4" class="px-6 py-4">Error loading data.</td></tr>`;
                            keyTakeawaysList.innerHTML = '<li class="text-gray-500">Simulation could not be run due to an unexpected error. Please check the console.</li>';
                        }
                    });
                };

                // --- Utility Functions ---

                /**
                 * Generates a random number with a normal-ish distribution (Bell Curve approximation)
                 * @returns {number} A random number between 0 and 1 with a normal-like distribution.
                 */
                const randn_bm = () => {
                    let u = 0, v = 0;
                    while(u === 0) u = Math.random();
                    while(v === 0) v = Math.random();
                    let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
                    num = num / 10.0 + 0.5;
                    if (num > 1 || num < 0) return randn_bm();
                    return num;
                }

                /**
                 * Generates all possible party combinations for coalition analysis.
                 * @param {Array<string>} arr An array of party names.
                 * @param {number} k The size of the combinations (e.g., 2 for two-party coalitions).
                 * @returns {Array<Array<string>>} An array of arrays, where each inner array is a combination.
                 */
                const getCombinations = (arr, k) => {
                    const result = [];
                    function backtrack(combo, start) {
                        if (combo.length === k) {
                            result.push([...combo]);
                            return;
                        }
                        for (let i = start; i < arr.length; i++) {
                            combo.push(arr[i]);
                            backtrack(combo, i + 1);
                            combo.pop();
                        }
                        return result;
                    }
                    backtrack([], 0);
                    return result;
                };

                /**
                 * Parses new poll data from the input fields.
                 * @returns {Object|null} An object containing the new poll data, or null if inputs are empty.
                 */
                const parseNewPollFromInputs = () => {
                    const newOverallPoll = {};
                    let hasValidData = false;
                    let overallSum = 0;

                    parties.forEach(p => {
                        const overallInput = document.getElementById(`overall-new-${p.name}`);
                        let overallValue = (overallInput && overallInput.value !== '') ? parseFloat(overallInput.value) : 0;
                        if (isNaN(overallValue) || overallValue < 0) overallValue = 0;
                        if (overallValue > 100) overallValue = 100;
                        if (overallInput && overallInput.value !== '') hasValidData = true;
                        newOverallPoll[p.name] = overallValue;
                        overallSum += overallValue;
                    });
                    
                    overallSumSpan.textContent = overallSum.toFixed(1);
                    if (Math.abs(overallSum - 100) > 0.5) {
                        overallSumSpan.classList.add('text-red-500');
                    } else {
                        overallSumSpan.classList.remove('text-red-500');
                    }
                    if (!hasValidData) return null;
                    return { overall: newOverallPoll };
                };

                /**
                 * Checks if a new poll from the input fields is a duplicate of recent polls.
                 * @param {Object} newPoll The new poll object.
                 * @param {Array<Object>} pollHistory An array of recent poll objects.
                 * @param {number} n The number of recent polls to check against.
                 * @returns {boolean} True if a duplicate is found, false otherwise.
                 */
                const isDuplicate = (newPoll, pollHistory, n) => {
                    const lastN = pollHistory.slice(-n);
                    return lastN.some(historicPoll => {
                        const overallMatch = parties.every(p => {
                            const historicVal = historicPoll.constituency[p.name] || 0;
                            const newVal = newPoll.overall[p.name] || 0;
                            return Math.abs(historicVal - newVal) < 0.1;
                        });
                        return overallMatch;
                    });
                };

                /**
                 * Calculates the seat distribution for a given set of vote percentages based on the electoral system type.
                 * @param {Object} votePercentages An object with vote percentages for each party.
                 * @param {string} systemType The electoral system type ('new_senedd' or 'old_senedd').
                 * @returns {Array<Object>} An array of party objects with their seat counts.
                 */
                const calculateSeats = (votePercentages, systemType) => {
                    const finalResults = parties.map(p => ({
                        ...p,
                        constituencySeats: 0,
                        regionalSeats: 0,
                        totalSeats: 0,
                        voteValue: votePercentages[p.name] || 0,
                    }));

                    if (systemType === 'new_senedd') {
                        const totalSeats = totalNewSeneddSeats;
                        let remainingSeats = totalSeats;
                        const seatAllocation = {};
                        parties.forEach(p => seatAllocation[p.name] = 0);
                        const dHondtDivisors = {};
                        parties.forEach(p => dHondtDivisors[p.name] = 1);

                        while (remainingSeats > 0) {
                            let highestQuotient = -1;
                            let winnerName = null;
                            for (const party of finalResults) {
                                const currentDivisor = dHondtDivisors[party.name] || 1;
                                const quotient = party.voteValue / currentDivisor;
                                if (quotient > highestQuotient) {
                                    highestQuotient = quotient;
                                    winnerName = party.name;
                                }
                            }
                            if (winnerName) {
                                const winningParty = finalResults.find(p => p.name === winnerName);
                                if (winningParty) {
                                    seatAllocation[winningParty.name]++;
                                    dHondtDivisors[winningParty.name] = (dHondtDivisors[winningParty.name] || 0) + 1;
                                }
                            }
                            remainingSeats--;
                        }
                        finalResults.forEach(p => {
                            p.totalSeats = seatAllocation[p.name];
                            p.constituencySeats = p.totalSeats;
                            p.regionalSeats = 0;
                        });
                    } else if (systemType === 'old_senedd') {
                        // Old Senedd System is not used in this simulation, but the logic is here for completeness.
                        let remainingOldConstituencySeats = totalOldConstituencySeats;
                        const oldConstituencySeatAllocation = {};
                        parties.forEach(p => oldConstituencySeatAllocation[p.name] = 0);
                        const sortedConstituencyParties = [...finalResults].sort((a, b) => (votePercentages.constituency[b.name] || 0) - (votePercentages.constituency[a.name] || 0));
                        sortedConstituencyParties.forEach(party => {
                            const votes = votePercentages.constituency[party.name] || 0;
                            const seats = Math.floor((votes / 100) * totalOldConstituencySeats);
                            oldConstituencySeatAllocation[party.name] = seats;
                            remainingOldConstituencySeats -= seats;
                        });
                        
                        if (remainingOldConstituencySeats > 0) {
                            const fractionalParties = sortedConstituencyParties
                                .map(party => ({
                                    name: party.name,
                                    fraction: (((votePercentages.constituency[party.name] || 0) / 100) * totalOldConstituencySeats) % 1
                                }))
                                .sort((a, b) => b.fraction - a.fraction);
                            for (let i = 0; i < remainingOldConstituencySeats; i++) {
                                if (fractionalParties[i] && oldConstituencySeatAllocation[fractionalParties[i].name] !== undefined) {
                                    oldConstituencySeatAllocation[fractionalParties[i].name]++;
                                }
                            }
                        }
                        
                        finalResults.forEach(p => {
                            p.constituencySeats = oldConstituencySeatAllocation[p.name] || 0;
                        });

                        let remainingOldRegionalSeats = totalOldRegionalSeats;
                        while (remainingOldRegionalSeats > 0) {
                            let highestValue = -1;
                            let winnerName = null;
                            for (const party of finalResults) {
                                const divisor = party.constituencySeats + party.regionalSeats + 1;
                                const value = (votePercentages.regional[party.name] || 0) / divisor;
                                if (value > highestValue) {
                                    highestValue = value;
                                    winnerName = party.name;
                                }
                            }
                            if (winnerName) {
                                const winningParty = finalResults.find(p => p.name === winnerName);
                                if (winningParty) {
                                    winningParty.regionalSeats++;
                                }
                            }
                            remainingOldRegionalSeats--;
                        }
                        
                        finalResults.forEach(p => {
                            p.totalSeats = p.constituencySeats + p.regionalSeats;
                        });
                    }
                    return finalResults.sort((a, b) => b.totalSeats - a.totalSeats);
                };

                /**
                 * Determines the political viability rating (Red, Amber, Green) for a coalition.
                 * @param {Array<string>} coalitionParties An array of party names in the coalition.
                 * @returns {string} The RAG rating ('red', 'amber', or 'green').
                 */
                const getRagRating = (coalitionParties) => {
                    const hasLabour = coalitionParties.includes('Labour');
                    const hasPlaidCymru = coalitionParties.includes('Plaid Cymru');
                    const hasConservative = coalitionParties.includes('Conservative');
                    const hasLiberalDemocrats = coalitionParties.includes('Liberal Democrats');
                    const hasGreen = coalitionParties.includes('Green');
                    const hasReform = coalitionParties.includes('Reform');

                    // Rule 1: Highly unlikely or problematic coalitions are Red.
                    if (
                        (hasLabour && hasConservative) || 
                        (hasPlaidCymru && hasConservative) || 
                        (hasReform) ||
                        (hasConservative && hasLiberalDemocrats && hasPlaidCymru) ||
                        (hasLabour && hasGreen && hasConservative)
                    ) {
                        return 'red';
                    }

                    // Rule 2: Most politically viable, stable alliances are Green.
                    if (
                        (hasLabour && hasPlaidCymru) ||
                        (hasLabour && hasGreen) ||
                        (hasPlaidCymru && hasGreen)
                    ) {
                        return 'green';
                    }

                    // Rule 3: All other plausible combinations are Amber.
                    if (
                        (hasLabour && hasLiberalDemocrats) ||
                        (hasPlaidCymru && hasLiberalDemocrats) ||
                        (hasConservative && hasLiberalDemocrats)
                    ) {
                        return 'amber';
                    }

                    // A fallback to amber for any other valid combination
                    return 'amber';
                };

                // --- Monte Carlo Simulation ---
                
                /**
                 * The main Monte Carlo simulation function. It runs the simulations and updates the UI.
                 */
                const runMonteCarloSimulation = () => {
                    console.log("runMonteCarloSimulation started.");
                    try {
                        const majorityCounter = {};
                        const pluralityCounter = {};
                        const seatTotaler = {};
                        const coalitionMajorityCounts = {};
                        const coalitionNearMajorityCounts = {};
                        const coalitionSeatTotals = {};
                        const coalitionMaxSeats = {};
                        const baseCoalitionSeniorityTracker = {};

                        const minPartySeats = {};
                        const maxPartySeats = {};

                        parties.forEach(p => {
                            majorityCounter[p.name] = 0;
                            pluralityCounter[p.name] = 0;
                            seatTotaler[p.name] = { constituency: 0, regional: 0, total: 0 };
                            minPartySeats[p.name] = Infinity;
                            maxPartySeats[p.name] = -Infinity;
                        });

                        const coalitionParties = mainParties;
                        const twoPartyCombos = getCombinations(coalitionParties, 2);
                        const threePartyCombos = getCombinations(coalitionParties, 3);
                        const allCombos = [...twoPartyCombos, ...threePartyCombos];

                        allCombos.forEach(combo => {
                            const baseCoalitionKey = [...combo].sort().join(' + ');
                            coalitionMajorityCounts[baseCoalitionKey] = 0;
                            coalitionNearMajorityCounts[baseCoalitionKey] = 0;
                            coalitionSeatTotals[baseCoalitionKey] = 0;
                            coalitionMaxSeats[baseCoalitionKey] = 0;
                            baseCoalitionSeniorityTracker[baseCoalitionKey] = { totalOccurrences: 0 };
                            combo.forEach(pName => {
                                baseCoalitionSeniorityTracker[baseCoalitionKey][pName] = 0;
                            });
                        });

                        const newPollInput = parseNewPollFromInputs();
                        let pollsForSimulation = [...currentPollsInUse];

                        if (newPollInput && (Object.values(newPollInput.overall).some(v => v > 0))) {
                            const normalizedNewPoll = {
                                constituency: normalizeVotes(newPollInput.overall),
                                regional: {}
                            };
                            if (!isDuplicate(normalizedNewPoll, currentPollsInUse, 3)) {
                                pollsForSimulation = pollsForSimulation.slice(-4);
                                pollsForSimulation.push(normalizedNewPoll);
                                showTempMessage("New poll added to simulation!", "text-green-600");
                            } else {
                                showTempMessage("New poll is a duplicate of recent polls and was not added.", "text-gray-500");
                            }
                        } else if (newPollInput) {
                            showTempMessage("New poll data incomplete or invalid. Using existing polls.", "text-amber-600");
                        }

                        const avgOverall = {};
                        parties.forEach(p => {
                            avgOverall[p.name] = pollsForSimulation.reduce((sum, poll) => sum + (poll.constituency[p.name] || 0), 0) / pollsForSimulation.length;
                        });
                        
                        for (let i = 0; i < numSimulations; i++) {
                            const simulatedOverall = {};
                            const trendToApply = averagedHistoricalTrend;
                            
                            parties.forEach(p => {
                                const partyJitterRange = p.jitterFactor * (avgOverall[p.name] || 0);
                                const overallJitter = (randn_bm() - 0.5) * 2 * partyJitterRange;
                                
                                simulatedOverall[p.name] = (avgOverall[p.name] || 0) + (trendToApply.old_constituency[p.name] || 0) + overallJitter;
                            });

                            const normalizedOverall = normalizeVotes(simulatedOverall);
                            const simulatedResults = calculateSeats(normalizedOverall, 'new_senedd');
                            const resultsMap = simulatedResults.reduce((acc, curr) => { acc[curr.name] = curr; return acc; }, {});

                            simulatedResults.forEach(result => {
                                seatTotaler[result.name].constituency += result.constituencySeats;
                                seatTotaler[result.name].regional += result.regionalSeats;
                                seatTotaler[result.name].total += result.totalSeats;

                                if (result.totalSeats < minPartySeats[result.name]) {
                                    minPartySeats[result.name] = result.totalSeats;
                                }
                                if (result.totalSeats > maxPartySeats[result.name]) {
                                    maxPartySeats[result.name] = result.totalSeats;
                                }
                            });

                            if (simulatedResults.length > 0 && simulatedResults[0].name !== 'Others') {
                                if (simulatedResults.length === 1 || simulatedResults[0].totalSeats > simulatedResults[1].totalSeats) {
                                    pluralityCounter[simulatedResults[0].name]++;
                                }
                            }

                            allCombos.forEach(combo => {
                                const baseCoalitionKey = [...combo].sort().join(' + ');
                                const sortedComboBySeats = [...combo].sort((a, b) => (resultsMap[b]?.totalSeats || 0) - (resultsMap[a]?.totalSeats || 0));
                                
                                baseCoalitionSeniorityTracker[baseCoalitionKey].totalOccurrences++;
                                if (sortedComboBySeats[0]) {
                                    baseCoalitionSeniorityTracker[baseCoalitionKey][sortedComboBySeats[0]]++;
                                }

                                const coalitionTotalSeats = combo.reduce((sum, partyName) => sum + (resultsMap[partyName]?.totalSeats || 0), 0);
                                
                                coalitionSeatTotals[baseCoalitionKey] += coalitionTotalSeats;
                                if (coalitionTotalSeats > coalitionMaxSeats[baseCoalitionKey]) {
                                    coalitionMaxSeats[baseCoalitionKey] = coalitionTotalSeats;
                                }

                                if (coalitionTotalSeats >= majoritySeats) {
                                    coalitionMajorityCounts[baseCoalitionKey]++;
                                }
                                if (coalitionTotalSeats >= nearMajoritySeats && coalitionTotalSeats < majoritySeats) {
                                    coalitionNearMajorityCounts[baseCoalitionKey]++;
                                }
                            });
                        }
                        
                        const majorityProbabilities = {};
                        const pluralityProbabilities = {};
                        const averageSeats = {};
                        const coalitionMajorityProbs = {};
                        const coalitionNearMajorityProbs = {};
                        const averageCoalitionSeats = {};

                        parties.forEach(p => {
                            majorityProbabilities[p.name] = (majorityCounter[p.name] / numSimulations * 100).toFixed(2);
                            pluralityProbabilities[p.name] = (pluralityCounter[p.name] / numSimulations * 100).toFixed(2);
                            averageSeats[p.name] = {
                                constituency: (seatTotaler[p.name].constituency / numSimulations),
                                regional: (seatTotaler[p.name].regional / numSimulations),
                                total: (seatTotaler[p.name].total / numSimulations)
                            };
                        });
                        
                        Object.keys(coalitionSeatTotals).forEach(key => {
                            coalitionMajorityProbs[key] = (coalitionMajorityCounts[key] / numSimulations * 100).toFixed(2);
                            coalitionNearMajorityProbs[key] = (coalitionNearMajorityCounts[key] / numSimulations * 100).toFixed(2);
                            averageCoalitionSeats[key] = (coalitionSeatTotals[key] / numSimulations);
                        });

                        lastSimResults.majorityProbabilities = majorityProbabilities;
                        lastSimResults.pluralityProbabilities = pluralityProbabilities;
                        lastSimResults.averageSeats = averageSeats;
                        
                        const rawCoalitionsForDisplay = Object.keys(averageCoalitionSeats).map(key => {
                            const partiesInKey = key.split(' + ');
                            const currentMaxSeats = coalitionMaxSeats[key] || 0;
                            
                            return {
                                name: key,
                                parties: partiesInKey,
                                baseCoalitionKey: key,
                                majority: parseFloat(coalitionMajorityProbs[key] || 0),
                                nearMajority: parseFloat(coalitionNearMajorityProbs[key] || 0),
                                averageSeats: parseFloat(averageCoalitionSeats[key] || 0),
                                maxSeats: currentMaxSeats
                            };
                        });

                        const filteredCoalitionsForDisplay = rawCoalitionsForDisplay.filter(c => c.majority > 0 || c.nearMajority > 0);

                        const nonRedundantCoalitionsForDisplay = filteredCoalitionsForDisplay.filter(coalition => {
                            for (let i = 0; i < coalition.parties.length; i++) {
                                const subCombinations = getCombinations(coalition.parties, i + 1);
                                for (const subCombo of subCombinations) {
                                    if (subCombo.length < coalition.parties.length) {
                                        const subComboAvgSeats = subCombo.reduce((sum, partyName) => sum + (averageSeats[partyName]?.total || 0), 0);
                                        if (subComboAvgSeats >= majoritySeats) {
                                            return false;
                                        }
                                    }
                                }
                            }
                            return true;
                        });
                        
                        lastSimResults.coalitionsToRender = nonRedundantCoalitionsForDisplay.map(c => {
                            const sortedPartiesForDisplayName = [...c.parties].sort((a, b) => {
                                const seatsA = averageSeats[a]?.total || 0;
                                const seatsB = averageSeats[b]?.total || 0;
                                return seatsB - seatsA;
                            });
                            const displayName = sortedPartiesForDisplayName.join(' + ');

                            return {
                                ...c,
                                displayName: displayName
                            };
                        }).sort((a, b) => {
                            if (b.majority !== a.majority) {
                                return b.majority - a.majority;
                            }
                            if (b.nearMajority !== a.nearMajority) {
                                return b.nearMajority - a.nearMajority;
                            }
                            return b.averageSeats - a.averageSeats;
                        });

                        renderProbabilities(majorityProbabilities, pluralityProbabilities);
                        // FIX: Pass all required data to the coalition rendering function
                        renderCoalitionProbabilities(lastSimResults.coalitionsToRender, lastSimResults.averageSeats, baseCoalitionSeniorityTracker);
                        renderForecastedSeats(averageSeats, minPartySeats, maxPartySeats);
                        renderKeyTakeaways();

                    } catch (error) {
                        console.error("Error during Monte Carlo simulation run:", error);
                        showTempMessage("An error occurred during simulation. Check console for details.", "text-red-500");
                        probabilityTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="3" class="px-6 py-4">Error during simulation.</td></tr>`;
                        coalitionTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="5" class="px-6 py-4">Error during simulation.</td></tr>`;
                        forecastedSeatsTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="4" class="px-6 py-4">Error during simulation.</td></tr>`;
                        keyTakeawaysList.innerHTML = '<li class="text-gray-500">Simulation could not be run due to an unexpected error. Please check the console.</li>';
                    }
                };

                // --- UI Rendering Functions ---

                /**
                 * Renders the input fields for a new poll.
                 */
                const renderInputs = () => {
                    newOverallInputsDiv.innerHTML = '';
                    parties.forEach(p => {
                        const overallRow = createInputHtml(p, 'overall');
                        newOverallInputsDiv.innerHTML += overallRow;
                    });
                    document.querySelectorAll('input[type="number"]').forEach(input => {
                        input.addEventListener('input', () => {
                            parseNewPollFromInputs();
                        });
                    });
                };

                /**
                 * Creates the HTML string for a single party's input field.
                 * @param {Object} party The party object with name and color.
                 * @param {string} type The type of input ('overall', 'constituency', or 'regional').
                 * @returns {string} The HTML string for the input field.
                 */
                const createInputHtml = (party, type) => `
                    <div class="flex items-center space-x-4 bg-gray-50 p-3 rounded-lg border border-gray-200">
                        <div class="w-4 h-4 rounded-full" style="background-color: ${party.color};"></div>
                        <label for="${type}-new-${party.name}" class="flex-1 font-medium text-gray-700">${party.name}</label>
                        <div class="flex items-center gap-2">
                            <input
                                id="${type}-new-${party.name}"
                                type="number"
                                step="0.1"
                                min="0"
                                max="100"
                                placeholder="e.g. 35.2"
                                class="w-24 text-center rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
                            />
                            <span class="text-gray-500">%</span>
                        </div>
                    </div>
                `;

                /**
                 * Renders the table of majority and plurality probabilities.
                 * @param {Object} majorityProbabilities An object with party names as keys and majority probabilities as values.
                 * @param {Object} pluralityProbabilities An object with party names as keys and plurality probabilities as values.
                 */
                const renderProbabilities = (majorityProbabilities, pluralityProbabilities) => {
                    if (!majorityProbabilities || Object.keys(majorityProbabilities).length === 0) {
                        probabilityTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="3" class="px-6 py-4">No data available for simulation.</td></tr>`;
                        return;
                    }
                    
                    probabilityTableBody.innerHTML = '';
                    const sortedParties = parties.map(p => ({
                        ...p,
                        majorityProb: parseFloat(majorityProbabilities[p.name]),
                        pluralityProb: parseFloat(pluralityProbabilities[p.name])
                    })).filter(p => p.majorityProb > 0 || p.pluralityProb > 0).sort((a, b) => b.pluralityProb - a.pluralityProb);

                    if (sortedParties.length === 0) {
                        probabilityTableBody.innerHTML = `
                            <tr class="text-center text-gray-500 italic">
                                <td colspan="3" class="px-6 py-4">No parties have a statistical chance of winning a majority or plurality based on the simulation.</td>
                            </tr>
                        `;
                        return;
                    }

                    sortedParties.forEach(party => {
                        const row = `
                            <tr class="hover:bg-gray-50 transition-colors">
                                <td class="px-6 py-4 whitespace-nowrap">
                                    <div class="flex items-center">
                                        <div class="flex-shrink-0 h-4 w-4 rounded-full" style="background-color: ${party.color};"></div>
                                        <div class="ml-3 text-sm font-medium text-gray-900">${party.name}</div>
                                    </div>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${party.majorityProb}%
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${party.pluralityProb}%
                                </td>
                            </tr>
                        `;
                        probabilityTableBody.innerHTML += row;
                    });
                };
                
                /**
                 * Renders the coalition analysis table.
                 * @param {Array<Object>} coalitionsToRender An array of coalition objects to display.
                 * @param {Object} individualAvgSeats Average seats for individual parties.
                 * @param {Object} baseCoalitionSeniorityTracker Seniority tracker for coalitions.
                 */
                const renderCoalitionProbabilities = (coalitionsToRender, individualAvgSeats, baseCoalitionSeniorityTracker) => {
                    coalitionMessageDiv.textContent = '';
                    
                    if (!coalitionsToRender || coalitionsToRender.length === 0) {
                        coalitionTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="5" class="px-6 py-4">No data available for coalition analysis.</td></tr>`;
                        updateCoalitionMessage();
                        return;
                    }

                    coalitionTableBody.innerHTML = '';
                    coalitionsToRender.forEach(coalition => {
                        const ragRating = getRagRating(coalition.parties);
                        const hiddenClass = ((hiddenRed && ragRating === 'red') || (hiddenAmber && ragRating === 'amber')) ? 'hidden-row' : '';
                        
                        let seniorityHtml = '';
                        const seniorityInfo = baseCoalitionSeniorityTracker[coalition.baseCoalitionKey];
                        if (seniorityInfo && seniorityInfo.totalOccurrences > 0) {
                            const sortedSeniorityParties = Object.keys(seniorityInfo).filter(pName => pName !== 'totalOccurrences').sort((a, b) => seniorityInfo[b] - seniorityInfo[a]);
                            seniorityHtml = sortedSeniorityParties.map(pName => {
                                const prob = ((seniorityInfo[pName] / seniorityInfo.totalOccurrences) * 100).toFixed(1);
                                return `<div class="flex items-center justify-between text-xs text-gray-600"><span>${pName}:</span> <span>${prob}%</span></div>`;
                            }).join('');
                        } else {
                            seniorityHtml = '<span class="text-gray-400 text-xs">N/A</span>';
                        }
                        const row = `
                            <tr class="hover:bg-gray-50 transition-colors ${hiddenClass}" data-rag-rating="${ragRating}">
                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                                    ${coalition.displayName} <span class="text-gray-500 font-normal">(${coalition.averageSeats.toFixed(2)} / ${coalition.maxSeats})</span>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center">
                                    <span class="rag-dot rag-${ragRating}"></span>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${coalition.majority}%
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${coalition.nearMajority}%
                                </td>
                                <td class="px-6 py-4 text-left text-sm">
                                    ${seniorityHtml}
                                </td>
                            </tr>
                        `;
                        coalitionTableBody.innerHTML += row;
                    });
                    updateCoalitionMessage();
                };
                
                /**
                 * Renders the table of forecasted seat distribution.
                 * @param {Object} averageSeats Average seats per party.
                 * @param {Object} minPartySeats Minimum seats per party in simulations.
                 * @param {Object} maxPartySeats Maximum seats per party in simulations.
                 */
                const renderForecastedSeats = (averageSeats, minPartySeats, maxPartySeats) => {
                    if (!averageSeats || Object.keys(averageSeats).length === 0) {
                        forecastedSeatsTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="2" class="px-6 py-4">No data available for simulation.</td></tr>`;
                        return;
                    }
                    forecastedSeatsTableBody.innerHTML = '';
                    const sortedParties = parties.map(p => ({
                        ...p,
                        seats: averageSeats[p.name]
                    })).sort((a, b) => parseFloat(b.seats?.total || 0) - parseFloat(a.seats?.total || 0));

                    if (sortedParties.length === 0) {
                        forecastedSeatsTableBody.innerHTML = `
                            <tr class="text-center text-gray-500 italic">
                                <td colspan="2" class="px-6 py-4">No seats could be allocated based on the simulation.</td>
                            </tr>
                        `;
                        return;
                    }
                    sortedParties.forEach(party => {
                        const row = `
                            <tr class="hover:bg-gray-50 transition-colors">
                                <td class="px-6 py-4 whitespace-nowrap">
                                    <div class="flex items-center">
                                        <div class="flex-shrink-0 h-4 w-4 rounded-full" style="background-color: ${party.color};"></div>
                                        <div class="ml-3 text-sm font-medium text-gray-900">${party.name}</div>
                                    </div>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${(party.seats?.total || 0).toFixed(1)}
                                </td>
                            </tr>
                        `;
                        forecastedSeatsTableBody.innerHTML += row;
                    });
                };

                /**
                 * Toggles the visibility of coalition rows based on their RAG rating.
                 * @param {string} rating The RAG rating to toggle ('red' or 'amber').
                 */
                const toggleCoalitionVisibility = (rating) => {
                    const button = document.getElementById(`toggle-${rating}-button`);
                    let isHidden;
                    if (rating === 'red') {
                        hiddenRed = !hiddenRed;
                        isHidden = hiddenRed;
                    } else if (rating === 'amber') {
                        hiddenAmber = !hiddenAmber;
                        isHidden = hiddenAmber;
                    }
                    const colorName = rating.charAt(0).toUpperCase() + rating.slice(1);
                    if (isHidden) {
                        button.textContent = `Show ${colorName} rated coalitions`;
                        button.classList.remove(`bg-${rating}-500`);
                        button.classList.add(`bg-gray-500`);
                    } else {
                        button.textContent = `Hide ${colorName} rated coalitions`;
                        button.classList.add(`bg-${rating}-500`);
                        button.classList.remove('bg-gray-500');
                    }
                    document.querySelectorAll(`#coalition-table tr[data-rag-rating="${rating}"]`).forEach(row => {
                        if (isHidden) {
                            row.classList.add('hidden-row');
                        } else {
                            row.classList.remove('hidden-row');
                        }
                    });
                    updateCoalitionMessage();
                };
                
                /**
                 * Updates the coalition message displayed below the table based on visible rows.
                 */
                const updateCoalitionMessage = () => {
                    const visibleRowsInTable = document.querySelectorAll('#coalition-table tr:not(.hidden-row)').length;
                    if (visibleRowsInTable === 0 && lastSimResults.coalitionsToRender.length > 0) {
                        coalitionMessageDiv.textContent = 'No coalitions are visible based on your filter settings.';
                    } else {
                        coalitionMessageDiv.textContent = '';
                    }
                };
                
                /**
                 * Generates and renders the key takeaways list based on simulation results.
                 */
                const renderKeyTakeaways = () => {
                    if (!lastSimResults.averageSeats || Object.keys(lastSimResults.averageSeats).length === 0) {
                        keyTakeawaysList.innerHTML = `<li class="text-gray-500">Simulation could not be run due to a data fetching error.</li>`;
                        return;
                    }

                    keyTakeawaysList.innerHTML = '';
                    const takeaways = [];
                    const sortedPlurality = parties.map(p => ({
                        name: p.name,
                        plurality: parseFloat(lastSimResults.pluralityProbabilities[p.name]),
                        majority: parseFloat(lastSimResults.majorityProbabilities[p.name])
                    })).sort((a, b) => b.plurality - a.plurality);

                    if (sortedPlurality.length > 0) {
                        const maxPluralityProb = sortedPlurality[0].plurality;
                        const topParties = sortedPlurality.filter(p => p.plurality === maxPluralityProb);
                        
                        let outcomeText;
                        if (topParties.length === 1) {
                            const topParty = topParties[0];
                            outcomeText = `The simulation suggests that <b>${topParty.name}</b> is most likely to emerge as the largest party in the Welsh Senedd, <b>achieving a plurality in ${topParty.plurality}% of the simulated elections</b>. They are <b>strongly positioned</b> to form a government, if they can secure support from other parties.`;
                            
                        } else {
                            const partyNames = topParties.map(p => `<b>${p.name}</b>`).join(' and ');
                            outcomeText = `The simulation indicates a highly competitive race for the largest party, with ${partyNames} each having a ${maxPluralityProb}% chance of securing a plurality. This suggests a strong likelihood of a hung Senedd due to frequent ties for the top position.`;
                        }
                        takeaways.push(outcomeText);
                    } else {
                        takeaways.push("No parties could be identified as having a statistical chance of winning a majority or plurality based on the simulation results.");
                    }

                    const greenCoalitions = lastSimResults.coalitionsToRender.filter(c => getRagRating(c.parties) === 'green');
                    const amberCoalitions = lastSimResults.coalitionsToRender.filter(c => getRagRating(c.parties) === 'amber');

                    if (greenCoalitions.length > 0) {
                        const topGreen = greenCoalitions[0];
                        let coalitionText = `Forming a stable Welsh Government appears viable through coalition. The most politically viable option is a <b>${topGreen.displayName}</b> coalition, `;
                        if (topGreen.majority > 0) {
                            coalitionText += `which <b>achieves a majority in ${topGreen.majority}% of the simulated elections</b>.`;
                        } else {
                            coalitionText += `which <b>does not achieve a majority in our simulations</b>. However, it does reach a near-majority (46-48 seats) in which a minority government is feasible in <b>${topGreen.nearMajority}%</b> of the simulated elections. This would require the support of only 1-2 other members from other parties to conduct its business.`;
                        }
                        takeaways.push(coalitionText);
                    } else if (amberCoalitions.length > 0) {
                        const topAmber = amberCoalitions[0];
                        let coalitionText = `Forming a majority Welsh Government may be challenging. The most likely coalition, though with some political hurdles, is a <b>${topAmber.displayName}</b> alliance, `;
                        if (topAmber.majority > 0) {
                            coalitionText += `which <b>achieves a majority in ${topAmber.majority}% of the simulated elections</b>.`;
                        } else {
                            coalitionText += `which <b>does not achieve a majority in our simulations</b>. However, it does reach a near-majority (46-48 seats) in which a minority government is feasible in <b>${topAmber.nearMajority}%</b> of the simulated elections. This would require the support of only 1-2 other members from other parties to conduct its business.`;
                        }
                        takeaways.push(coalitionText);
                    } else {
                        takeaways.push("The simulations indicate significant challenges in forming a stable majority coalition in the Welsh Senedd.");
                    }

                    const sortedSeats = parties.map(p => ({
                        name: p.name,
                        totalSeats: (lastSimResults.averageSeats[p.name]?.total || 0)
                    })).sort((a, b) => (lastSimResults.averageSeats[b.name]?.total || 0) - (lastSimResults.averageSeats[a.name]?.total || 0));

                    if (sortedSeats.length >= 2) {
                        const leader = sortedSeats[0];
                        const second = sortedSeats[1];
                        const seatDifference = leader.totalSeats - second.totalSeats;
                        let swingText;
                        if (leader.totalSeats < majoritySeats) {
                            if (seatDifference > 0) {
                                const seatsToShift = Math.ceil(seatDifference / 2);
                                const avgVotePerSeat = 100 / totalNewSeneddSeats;
                                const estimatedVoteSwingNeeded = (seatsToShift * avgVotePerSeat);
                                swingText = `The race for the largest party in the Welsh Senedd is exceptionally close between <b>${leader.name}</b> (average ${leader.totalSeats.toFixed(1)} seats) and <b>${second.name}</b> (average ${second.totalSeats.toFixed(1)} seats). A swing of approximately <b>${estimatedVoteSwingNeeded.toFixed(2)}%</b> from <b>${leader.name}</b> to <b>${second.name}</b> in the overall vote would be needed for <b>${second.name}</b> to become the largest party.`;
                            } else {
                                swingText = `The leading parties are neck-and-neck, indicating a highly unpredictable outcome where even a small shift in votes could change the largest party under the new electoral system.`;
                            }
                        } else {
                            swingText = `The distribution of seats under the new multi-member constituency system emphasizes proportional representation across Wales.`;
                        }
                        takeaways.push(swingText);
                    } else {
                        takeaways.push("Further analysis is needed to identify key dynamics, as seat distribution is currently limited.");
                    }

                    takeaways.forEach(text => {
                        const listItem = document.createElement('li');
                        listItem.innerHTML = text;
                        keyTakeawaysList.appendChild(listItem);
                    });
                };

                /**
                 * Renders the table of current polls.
                 * @param {Array<Object>} polls An array of current poll objects.
                 */
                const renderCurrentPollsTable = (polls) => {
                    currentPollsTableBody.innerHTML = '';
                    partyHeadersRow.innerHTML = '';

                    if (!polls || polls.length === 0) {
                        currentPollsMessageDiv.textContent = 'No current polls available to display.';
                        return;
                    }
                    currentPollsMessageDiv.textContent = '';

                    parties.forEach(p => {
                        partyHeadersRow.innerHTML += `<th scope="col" class="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">${p.name}</th>`;
                    });

                    for (let i = polls.length - 1; i >= 0; i--) {
                        const poll = polls[i];
                        const row = document.createElement('tr');
                        row.classList.add('hover:bg-gray-50', 'transition-colors');

                        const dateCell = document.createElement('td');
                        dateCell.classList.add('px-3', 'py-2', 'whitespace-nowrap', 'text-sm', 'font-medium', 'text-gray-900');
                        dateCell.textContent = poll.rawDateString || 'No Date';
                        row.appendChild(dateCell);

                        const pollsterCell = document.createElement('td');
                        pollsterCell.classList.add('px-3', 'py-2', 'whitespace-nowrap', 'text-sm', 'text-gray-500');
                        pollsterCell.textContent = poll.pollster || 'N/A';
                        row.appendChild(pollsterCell);

                        parties.forEach(p => {
                            const cell = document.createElement('td');
                            cell.classList.add('px-3', 'py-2', 'whitespace-nowrap', 'text-center', 'text-sm', 'text-gray-500');
                            cell.textContent = (poll.constituency[p.name] || 0).toFixed(1) + '%';
                            row.appendChild(cell);
                        });
                        currentPollsTableBody.appendChild(row);
                    }
                };
                
                /**
                 * Displays a temporary message in the poll message container.
                 * @param {string} message The message text.
                 * @param {string} className The Tailwind CSS class for styling the message.
                 */
                const showTempMessage = (message, className) => {
                    pollMessageContainer.textContent = message;
                    pollMessageContainer.className = `text-center text-sm font-semibold h-5 mb-2 ${className}`;
                    setTimeout(() => {
                        pollMessageContainer.textContent = '';
                        pollMessageContainer.className = `text-center text-sm font-semibold h-5 mb-2`;
                    }, 5000);
                };
                
                // --- Event Listeners and Initialisation ---
                runSimulationButton.addEventListener('click', updateAndRunSimulation);
                toggleRedButton.addEventListener('click', () => toggleCoalitionVisibility('red'));
                toggleAmberButton.addEventListener('click', () => toggleCoalitionVisibility('amber'));
                enableTrendApplicationCheckbox.addEventListener('change', updateAndRunSimulation);

                renderInputs();
                updateAndRunSimulation();
            });
        })();
    </script>
</body>
</html>
FINALWalesSim.txt
Displaying FINALWalesSim.txt.
